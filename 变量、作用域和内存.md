# 变量、作用域和内存的问题
## 基本类型和引用类型的值
ECMAScript 变量可能包含两种不同数据类型的值：`基本类型值`和`引用类型值`。基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。
基本数据类型：`undefined`、`null`、`boolean`、`Number`、`string`、这5种基本类型直接按值来访问的，因为可以操作保存在变量中的实际的值。(只说es5里面的,es6里面新增的symbol先不说)

引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的。

> 在很多语言中，字符串以对象的形式来表示，因此被此认为是引用类型的。

定义基本类型值和引用类型值的方式是类似的：创建一个变量并为该变量赋值。但是，当这个值存到变量中以后，对不同类型值可以执行的操作则大相径庭，对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。
```
var person = new Object()
person.name = "limuen"
alert(person.name) //"limuen"
```

以上代码创建了一个对象并将其保存在了变量person中，然后，我们为该对象添加了一个名为name的属性，并将字符串`"limuen"`赋给了这个属性，紧接着我们直接通过了alert()函数访问了这个新属性。如果对象不对销毁或者这个属性不给删除，则这个属性(name)将一直会存在

但是，我们不能给基本类型的值添加属性，尽管这么做不会导致任何错误。
```
var name = "limuen"
name.age = 25
alert(name.age) //undefined
```
在这个例子中，我们为字符串name定义了一个名为age的属性，并为该属性赋值25，但在下一行访问这个属性的时候，发现该属性不见了。这说明只能给引用类型值动态的添加属性，以方便将来使用。

## 复制变量值

除了保存的方式不同之外，在从一个变量向另一个变量复制基本类型值和引用类型值时，也存在不同，如果从一个变量向另外一个变量赋值基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上
```
var num1 = 1
var num2 = num1
```
在此，num1中保存的值是5，当使用num1的值来初始化num2时，num2中也保存了值(1)，但是num2中的1与num1中的1是完全独立的，该值只是num1中1的一个副本，此后，这两个变量可以参与任何操作而不会互相影响。

当从一个变量向另外一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中，不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象，复制操作结束后，两个变量实际上将引用同一个对象，因此，改变其中一个变量就会影响另一个变量

```
var obj1 = new Object()
var obj2 = obj1
obj1.name = "limuen"
console.log(obj2.name) //"limuen"
``` 

## 传递参数
ECMAScript中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另外一个变量一样。基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样。但是访问变量有按值和按引两种方式，而参数只能按值传递

在向参数传递基本类型的值时，被传递的值会复制给一个局部变量（即命名参数，或者用ECMAScript的概念来说，就是arguments对象中的一个元素）。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反应在函数的外部

```
function addTem(num){
    num += 10
    return num
}
var count = 10
var result = addTem(count)
console.log(count) //10
console.log(result) //20
```

> 可以把ECMAScript函数的参数想象成局部变量

## 检测类型
具体的文章可以访问一下yck大佬写的 [前端面试之道](https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc715f6fb9a049c15ea4e0) 中的typeof和instanceof的区别

## 执行环境及作用域
执行环境是JavaScript中最为重要的一个概念，执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。

在web浏览器中，全局执行环境被认为是window对象，因此所有全局变量和函数都是作为`window`对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之被销毁（全局执行环境直到应用程序退出----例如关闭网页或者浏览器时才会被销毁）

每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而这个函数执行之后，栈将其环境弹出去，把控制权返回给之前的执行环境。

当代码在一个环境中执行的时候，会创建变量对象的一个`作用域链`。而`作用域链`的用途是保证对执行环境有权访问的`所有变量`和`函数`的有序访问。全局执行环境的变量对象始终都是作用域链中的最后一个对象。

```
var color = "blue"
function changColor(){
    if(color === "blue){
        color = "red"
    }else{
        color = "blue"
    }
}
changeColor()
console.log("Color is now" + color)
```
在这个简单的例子中，函数changeColor()的作用域链包含两个对象：它自己的变量对象（其中定义着arguments对象）和全局环境的变量对象。可以在函数内部访问变量color，就是因为可以在作用域链中找到它

此外，在局部作用域链中定义的变量可以在局部环境中与全局变量互相使用，下面这个例子所示

```
var color =  "red"
function changColor(){
    var anotherColor = "blue"
    functon swapColor(){
        var tempColor = anotherColor
        anotherColor = color
        color = tempColor

        //这里可以访问color、anotherColor、tempColor
    }
    //这里可以访问到anotherColor
    swapColor()
}
//这里只能访问color
changColor()
```
来一张图简单明了（md文件玩的不明白，将就的看一下 以后再仔细研究markdown）
```
  window
    ├── color                         
    ├── changColor()                             
          ├── anotherColor                        
          ├── swapColor()                      
                 ├── tempColor
```
内部环境可以通过作用域链访问所有的外部环境，但是外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性，有次序的。每个环境都可以向上搜索作用域链，以查询变量和函数名，但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。

> 函数参数也被当做变量来对象，因此其访问规则与执行环境中的其他变量相同


## 块级作用域

```
for(var i = 0; i<10;i++){
    console.log(i)
}
console.log(i) //10
```

对于块级作用域的语言来说，for语句初始化变量的表达式所定义的变量，只会存在于循环的环境之中，而对于JavaScript来说，由for语句创建的变量i即使在for循环执行结束后，也依旧存在与循环外部的执行环境中。


## 变量声明
使用var声明的变量会自动添加到最接近的环境中，在函数内部，最接近的环境就是函数的局部环境。如果初始化变量时没有使用var声明，该变量会自动添加到全局环境

```
function add(num1,num2){
    var sum = num1 + num2
    return sum
}
var result = add(10,20) //30
console.log(sum) //sum is not defined
```

```
function add(num1,num2){
    sum = num1 + num2
    return sum
}
var result = add(10,20) //30
console.log(sum) //30
```

> 在编写JavaScript代码的过程中，不声明而直接初始化变量是一个常见的错误做法，因为这样可能会导致意外。建议在初始化变量之前，一定要先声明，这样就可以避免类似问题，在严格模式下，初始化未经声明的变量会导致错误


## 查询标识符

当某个环境为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际什么，如果在局部变量中找到了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿着作用域链向上继续搜索，搜索过程将一直追溯到全局环境的变量对象（全局变量）。如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明

```
var color = "red"
function getColor(){
    return color
}
console.log(getColor()) //"red"
```

如果存在一个局部变量的定义，则搜索立即会停止，不再进入另一个变量对象也就是局部环境中存在着同名标识符，就不会使用位于父环境中的标识符。
```
var color = "red"
function getColor(){
    var color = "blue" //2.搜索到局部变量color，搜索停止 
    return color //1.开始搜索，
}
console.log(getColor()) // "blue"
```

变量查询也不是没有代价的，很明显，访问局部变量要比访问全局变量更快，因为不用再向上搜索作用域链。


# 总结

其实写到最后，感觉内存的问题前端运用的比较少（也有用到，后面会提.主要还是懒），就不想写了，如果想研究内存的问题的话，可以自行查找资料。

JavaScript变量可以用来保存两种类型的值：基本类型值和引用类型值。基本类型的值源自一下5中基本数据类型：Undefined、Null、Boolean、Number、String。基本类型值和引用类型值具有以下特点：

* 基本类型在内存中占据固定大小的空间，因此被保存在栈内存中
* 从一个变量到另一个变量复制基本类型的值，会创建这个值的一个副本
* 引用类型的值是对象，保存在堆内存中
* 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针
* 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象
* 确定一个值是哪种基本类型可以使用`typeof`操作符，而确定一个值是哪种引用类型可以使用`instanceof`操作符

所有变量（包括基本类型和引用类型）都存在与一个执行环境（也称作作用域）当中，这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量，以下是关于执行环境的几点总结：
* 执行环境有全局执行环境（也称为全局环境）和函数执行环境之分
* 每次进入一个新执行环境，都会创建一个用域搜索变量和函数的作用域链
* 函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，乃至全局环境
* 全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据
* 变量的执行环境有助于确定应该何时释放内存


对你有帮助的可以给个star哦
